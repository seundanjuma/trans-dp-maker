<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trans DP-Maker</title>
<style>
  :root{
    --bg:#fff; --text:#202124; --muted:#5f6368; --border:#dadce0;
    --accent:#4285f4; --btn-bg:#f8f9fa; --btn-hover:#f1f3f4;
    --radius-pill:24px; --radius-md:10px; --shadow:0 1px 6px rgba(0,0,0,.1);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    gap:18px;
    background:var(--bg);
    color:var(--text);
    text-align:center;
    padding:20px;
  }

  /* logo */
  #logo { width:160px; height:auto; display:block; margin-bottom:8px; }

  /* upload area (centered, stacked) */
  #uploadArea{ display:flex; flex-direction:column; align-items:center; gap:12px; }
  #uploadBox{
    width:320px; max-width:92vw;
    padding:16px;
    border:1px solid var(--border);
    border-radius:var(--radius-pill);
    background:#fff;
    box-shadow:var(--shadow);
    cursor:pointer;
  }
  #uploadBox:active{ transform: translateY(1px); }
  #uploadBtn{
    padding:10px 22px; border-radius:20px; border:1px solid var(--border);
    background:var(--btn-bg); cursor:pointer;
  }
  #uploadBtn:hover{ background:var(--btn-hover); }

  #upload{ display:none; }

  /* spinner */
  #spinner{ display:none; width:28px; height:28px; border-radius:50%;
    border:3px solid #e8eaed; border-top:3px solid var(--accent); animation:spin 1s linear infinite; }
  @keyframes spin{ to{ transform:rotate(360deg)} }

  /* canvas area */
  .canvas-wrapper{ position:relative; display:none; margin-top:6px; }
  canvas{
    width:400px; height:400px;
    border-radius:var(--radius-md);
    background:#fff;
    box-shadow:var(--shadow);
    border:1px solid #ddd;
    touch-action:none; cursor:grab;
  }
  @media(max-width:900px){ canvas{ width:360px; height:360px; } }
  @media(max-width:600px){ canvas{ width:300px; height:300px; } }

  #dragHint{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  #dragHint span{ background:rgba(0,0,0,.65); color:#fff; padding:8px 12px; border-radius:8px; font-size:14px; opacity:0; transform:translateY(6px); transition:all 200ms ease; }
  #dragHint.show span{ opacity:1; transform:translateY(0); }

  /* controls */
  #controls{ display:none; margin-top:10px; gap:10px; align-items:center; justify-content:center; }
  input[type=range]{ width:300px; }
  @media(max-width:600px){ input[type=range]{ width:200px; } }
  .btn{ padding:10px 14px; border-radius:20px; border:1px solid var(--border); background:var(--btn-bg); cursor:pointer; }
  .btn.primary{ background:var(--accent); color:#fff; border-color:transparent; }
  .btn:disabled{ background:#eee; cursor:not-allowed; color:#9aa0a6; }

  /* drag overlay full screen */
  #dragOverlay{
    display:none; position:fixed; inset:0; z-index:1000;
    background:rgba(200,200,200,.82); border:4px dashed #444;
    display:flex; align-items:center; justify-content:center;
  }
  #dragOverlay h2{ color:#222; font-size:22px; margin:0; }

  /* error toast */
  #error{ display:none; position:fixed; bottom:20px; left:50%; transform:translateX(-50%); background:#fbe9ea; color:#b71c1c; padding:8px 12px; border-radius:10px; border:1px solid #f3c2c0; box-shadow:var(--shadow); }
</style>
</head>
<body>

  <!-- logo.png must be in same folder -->
  <img id="logo" src="logo.png" alt="Trans DP-Maker logo" onerror="this.style.display='none'">

  <!-- Upload area -->
  <div id="uploadArea">
    <div id="uploadBox" tabindex="0" role="button">Drag here to upload</div>
    <button id="uploadBtn" class="btn">Upload</button>
    <input id="upload" type="file" accept="image/png,image/jpeg">
  </div>

  <!-- spinner (while loading image) -->
  <div id="spinner" aria-hidden="true"></div>

  <!-- canvas + hint -->
  <div class="canvas-wrapper" id="canvasWrapper">
    <canvas id="canvas" aria-label="Preview"></canvas>
    <div id="dragHint"><span>Drag image to move</span></div>
  </div>

  <!-- controls -->
  <div id="controls">
    <label for="zoom">Zoom</label>
    <input id="zoom" type="range" min="1" max="3" step="0.1" value="1">
    <button id="downloadBtn" class="btn primary" disabled>Download</button>
    <button id="resetBtn" class="btn">Reset</button>
  </div>

  <!-- full screen drag overlay -->
 <!-- <div id="dragOverlay"><h2>Drag to Upload</h2></div> -->

  <!-- error toast -->
  <div id="error" role="status" aria-live="polite"></div>

<script>
/* ---------- Config / elements ---------- */
const PREVIEW_SIZE = 1080;   // internal preview resolution
const EXPORT_SIZE  = 1280;   // export resolution

const uploadBox = document.getElementById('uploadBox');
const uploadBtn = document.getElementById('uploadBtn');
const fileInput = document.getElementById('upload');
const uploadArea = document.getElementById('uploadArea');
const spinner = document.getElementById('spinner');

const canvasWrapper = document.getElementById('canvasWrapper');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const dragHint = document.getElementById('dragHint');
const controls = document.getElementById('controls');
const zoomEl = document.getElementById('zoom');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');

const dragOverlay = document.getElementById('dragOverlay');
const errorToast = document.getElementById('error');

canvas.width = PREVIEW_SIZE;
canvas.height = PREVIEW_SIZE;

/* frame overlay (must exist) */
const frame = new Image();
frame.src = 'frame.png';

/* state */
let userImg = new Image();
let userLoaded = false;
let scale = 1;             // scale relative to image such that rendering at PREVIEW_SIZE uses this scale
let offsetX = 0, offsetY = 0; // pan offsets in PREVIEW coordinate space
let isDragging = false;
let startX = 0, startY = 0;
let lastPinchDist = null;

/* utility: show error toast */
function showError(msg){
  errorToast.textContent = msg;
  errorToast.style.display = 'block';
  setTimeout(()=> errorToast.style.display = 'none', 3000);
}

/* ---------- Core math: constraints & draw ---------- */

/*
 clampTransform():
  - ensures scale >= minScalePreview so image (even small) covers preview canvas
  - clamps offsetX/offsetY (in PREVIEW units) so image covers full preview (no blanks)
  - WORKS IN PREVIEW COORDINATES (so preview and export stay consistent)
*/
function clampTransform(){
  // ensure we have userImg
  if (!userImg || !userImg.width) return;

  // minimum scale (so image covers PREVIEW canvas)
  const minScalePreview = Math.max(PREVIEW_SIZE / userImg.width, PREVIEW_SIZE / userImg.height);
  if (scale < minScalePreview) scale = minScalePreview;

  // size of scaled image in PREVIEW coords
  const iw_preview = userImg.width * scale;
  const ih_preview = userImg.height * scale;

  // offsets must keep image covering the PREVIEW_SIZE canvas
  const minX = -(iw_preview - PREVIEW_SIZE);
  const maxX = 0;
  const minY = -(ih_preview - PREVIEW_SIZE);
  const maxY = 0;

  if (offsetX < minX) offsetX = minX;
  if (offsetX > maxX) offsetX = maxX;
  if (offsetY < minY) offsetY = minY;
  if (offsetY > maxY) offsetY = maxY;
}

/*
 draw(targetCanvas, targetCtx, size)
  - draws using the canonical transform (scale & offsets are stored in PREVIEW units)
  - when size !== PREVIEW_SIZE we scale the transform and image accordingly so the output
    is exactly the same composition but at different resolution.
*/
function draw(targetCanvas = canvas, targetCtx = ctx, size = PREVIEW_SIZE) {
  if (!userLoaded || !frame.complete) return;

  // enforce constraints in PREVIEW units
  clampTransform();

  // scale factor between requested output size and preview coordinate system
  const sf = size / PREVIEW_SIZE;

  // compute image sizes in output canvas units
  const iw_out = userImg.width * scale * sf;
  const ih_out = userImg.height * scale * sf;

  // compute offsets in output units (offsetX stored in PREVIEW units)
  const offsetX_out = offsetX * sf;
  const offsetY_out = offsetY * sf;

  // center correction in output units
  const x = offsetX_out + (size - iw_out) / 2;
  const y = offsetY_out + (size - ih_out) / 2;

  // set canvas to requested size and draw
  targetCanvas.width = size;
  targetCanvas.height = size;
  targetCtx.clearRect(0,0,size,size);
  targetCtx.drawImage(userImg, x, y, iw_out, ih_out);
  // frame drawn to exactly fit output size
  targetCtx.drawImage(frame, 0, 0, size, size);
}

/* ---------- File handling & UI transitions ---------- */

function handleFile(file){
  if (!file) return;
  const valid = ['image/png','image/jpeg'];
  if (!valid.includes(file.type)){
    showError('File type not supported. Please upload .png, .jpg or .jpeg.');
    return;
  }

  spinner.style.display = 'block';
  const reader = new FileReader();
  reader.onload = (e) => {
    userImg = new Image();
    userImg.onload = () => {
      spinner.style.display = 'none';
      // show workspace
      uploadArea.style.display = 'none';
      canvasWrapper.style.display = 'block';
      controls.style.display = 'flex';
      userLoaded = true;

      // initial auto-fit scale so image covers preview
      const sx = PREVIEW_SIZE / userImg.width;
      const sy = PREVIEW_SIZE / userImg.height;
      scale = Math.max(sx, sy);
      offsetX = 0; offsetY = 0;

      zoomEl.value = scale.toFixed(1);
      downloadBtn.disabled = false;

      // render preview
      draw();

      // show drag hint briefly
      dragHint.classList.add('show');
      setTimeout(()=> dragHint.classList.remove('show'), 2200);
    };
    userImg.src = e.target.result;
  };
  reader.readAsDataURL(file);
}

/* open file picker when clicking upload areas */
function openPicker(){ fileInput.click(); }
uploadBox.addEventListener('click', openPicker);
uploadBox.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); openPicker(); } });
uploadBtn.addEventListener('click', openPicker);
fileInput.addEventListener('change', e => handleFile(e.target.files[0]));

/* ---------- Drag overlay (full screen) ---------- */
window.addEventListener('dragover', e => { e.preventDefault(); dragOverlay.style.display = 'flex'; });
window.addEventListener('dragleave', e => { if (e.target === document || e.clientX <= 0 || e.clientY <= 0) dragOverlay.style.display = 'none'; });
window.addEventListener('drop', e => {
  e.preventDefault();
  dragOverlay.style.display = 'none';
  const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
  if (f) handleFile(f);
});

/* ---------- Controls: zoom, download, reset ---------- */
zoomEl.addEventListener('input', () => {
  // slider value is scale in PREVIEW units
  scale = parseFloat(zoomEl.value);
  clampTransform();
  draw();
});

downloadBtn.addEventListener('click', () => {
  if (!userLoaded) return;
  // create export canvas and draw at EXPORT_SIZE (same composition, higher res)
  const out = document.createElement('canvas');
  const octx = out.getContext('2d');
  draw(out, octx, EXPORT_SIZE);
  const a = document.createElement('a');
  a.download = 'dp-trans.png';
  a.href = out.toDataURL('image/png');
  a.click();
});

resetBtn.addEventListener('click', () => {
  userLoaded = false;
  uploadArea.style.display = 'flex';
  canvasWrapper.style.display = 'none';
  controls.style.display = 'none';
  ctx.clearRect(0,0,canvas.width, canvas.height);
  fileInput.value = '';
  downloadBtn.disabled = true;
});

/* ---------- Canvas interactions: drag (mouse) ---------- */
canvas.addEventListener('mousedown', (e) => {
  if (!userLoaded) return;
  isDragging = true;
  const sx = PREVIEW_SIZE / canvas.clientWidth;
  const sy = PREVIEW_SIZE / canvas.clientHeight;
  startX = e.offsetX * sx;
  startY = e.offsetY * sy;
  canvas.style.cursor = 'grabbing';
  dragHint.classList.remove('show');
});
window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
canvas.addEventListener('mouseleave', () => { isDragging = false; canvas.style.cursor = 'grab'; });
canvas.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  const sx = PREVIEW_SIZE / canvas.clientWidth;
  const sy = PREVIEW_SIZE / canvas.clientHeight;
  const curX = e.offsetX * sx;
  const curY = e.offsetY * sy;
  offsetX += (curX - startX);
  offsetY += (curY - startY);
  startX = curX; startY = curY;
  clampTransform();
  draw();
});

/* ---------- Touch: drag + pinch ---------- */
canvas.addEventListener('touchstart', (e) => {
  if (!userLoaded) return;
  if (e.touches.length === 1){
    isDragging = true;
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    dragHint.classList.remove('show');
  } else if (e.touches.length === 2){
    lastPinchDist = Math.hypot(
      e.touches[1].clientX - e.touches[0].clientX,
      e.touches[1].clientY - e.touches[0].clientY
    );
  }
}, {passive:false});

canvas.addEventListener('touchmove', (e) => {
  if (!userLoaded) return;
  e.preventDefault();
  if (e.touches.length === 1 && isDragging){
    const dx = e.touches[0].clientX - startX;
    const dy = e.touches[0].clientY - startY;
    // convert movement in screen px to PREVIEW units
    offsetX += dx * (PREVIEW_SIZE / canvas.clientWidth);
    offsetY += dy * (PREVIEW_SIZE / canvas.clientHeight);
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    clampTransform();
    draw();
  } else if (e.touches.length === 2){
    const dist = Math.hypot(
      e.touches[1].clientX - e.touches[0].clientX,
      e.touches[1].clientY - e.touches[0].clientY
    );
    if (lastPinchDist){
      const delta = dist / lastPinchDist;
      // update scale in PREVIEW units (scale stored is PREVIEW-based)
      scale *= delta;
      // enforce min scale immediately and clamp
      const minScalePreview = Math.max(PREVIEW_SIZE / userImg.width, PREVIEW_SIZE / userImg.height);
      if (scale < minScalePreview) scale = minScalePreview;
      if (scale > 6) scale = 6; // a sane upper limit
      zoomEl.value = scale.toFixed(2);
      clampTransform();
      draw();
    }
    lastPinchDist = dist;
  }
}, {passive:false});

canvas.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) lastPinchDist = null;
  if (e.touches.length === 0) isDragging = false;
});

/* ---------- Init UI state ---------- */
(function init(){
  canvasWrapper.style.display = 'none';
  controls.style.display = 'none';
  downloadBtn.disabled = true;
})();
</script>
</body>
</html>